<CsoundSynthesizer><CsOptions>-odac -d</CsOptions><CsInstruments>
sr = 44100ksmps = 32nchnls = 20dbfs = 1
#define DUMP_FILE_NAME #"cffg.txt"##define ALTERNATIVE_RULE_DELIM #1000000#
#include "C:\Users\win8\Desktop\csound\tmp\csd\include\math\stochastic\distribution3.inc.csd"#include "C:\Users\win8\Desktop\csound\tmp\csd\include\utils\table.v1.csd"#include "C:\Users\win8\Desktop\csound\tmp\csd\include\ling\formal_grammar2.class.csd"giSine    ftgen     0, 0, 2^10, 10, 1
;vocabulary/*a -1b -2c -3S 1D 2E 3F 4*/
gkRules[][] init  128, 128gkFinal[] init 128gkAlternativeProb[][] init  128, 128gkMinPeriod init 0.3instr 1	kStart		init 	0	kFlag		init 	1	kAmp		init 	.8	if kFlag == 1 then		kFlag = 0

		;fprintks 	$DUMP_FILE_NAME, "\n========================== arrays for Formal Grammar \n"		gkRules[0][0] = 1;S		gkRules[0][1] = 2;D		gkRules[0][2] = -1;a		gkRules[0][3] = -2;b		gkRules[0][4] = 0	;0		gkAlternativeProb[0][0]=0;
		gkRules[1][0]	= 3;E		gkRules[1][1]	= 4;F		gkRules[1][2]	= -1;a		gkRules[1][3]	= -3;c		gkRules[1][4]	= 0;0		gkAlternativeProb[1][0]=0;
		gkRules[2][0]	= 2;D		gkRules[2][1]	= 3;E		gkRules[2][2]	= -2;b		gkRules[2][3]	= -3;c		gkRules[2][4]	= $ALTERNATIVE_RULE_DELIM;|		gkRules[2][5]	= 4;F		gkRules[2][6]	= -2;b		gkRules[2][7]	= -2;b		gkRules[2][8]	= 0;0		gkAlternativeProb[2][0]=0.7;		gkAlternativeProb[2][1]=0.3;
		gkRules[3][0]	= 4;F		gkRules[3][1]	= -1;a		gkRules[3][2]	= -2;b		gkRules[3][3]	= -3;c		gkRules[3][4]	= $ALTERNATIVE_RULE_DELIM;|		gkRules[3][5]	= 3;E		gkRules[3][6]	= -1;a		gkRules[3][7]	= -1;a		gkRules[3][8]	= 0;0		gkAlternativeProb[3][0]=0.2;		gkAlternativeProb[3][1]=0.8;
		gkRules[4][0]	= 0;		gkFinal[0] = 1		gkFinal[1] = 0
		kTemporary[] init 128
		gkFinal = CFFG(gkRules, gkAlternativeProb, gkFinal)		kIndex = 0		fprintks 	$DUMP_FILE_NAME, "\n========================== final string\n"		while gkFinal[kIndex] != 0 do			fprintks 	$DUMP_FILE_NAME, "\ngkFinal[%d] = %f\n", kIndex, gkFinal[kIndex]			kIndex = kIndex + 1		od				kIndex = 0;		kPeriod 	= -1 * gkMinPeriod * gkFinal[kIndex]	endif		kTrig			metro	1/kPeriod	;metro for event generating	if kTrig == 1 then		if gkFinal[kIndex] != 0 then			/*				=======================================				=========		duration 		=======				=======================================			*/			kDur = kPeriod * .8			/*				=======================================				=========		pitch			=======				=======================================			*/			;kFrq = GetExp(kRawVal, 0.01, 1., kMinFrq, kMaxFrq)			kFrq = get_different_distrib_value_k(0, 7, 15., 1500., 2)						/*				=======================================				=========		play 			=======				=======================================			*/			kPan = get_different_distrib_value_k(0, 7, 0., 1., 1)			event  	"i", "simple_sin", kStart, kDur, kFrq, kAmp, kPan						/*				=======================================				=========	next note start		=======				=======================================			*/			kIndex = kIndex + 1;			if gkFinal[kIndex] != 0 then				kPeriod 	= -1 * gkMinPeriod * gkFinal[kIndex]			endif		endif			endifendininstr simple_sin	iAmp = p5	iFrq = p4	kPan = p6	kenv      linen     1, p3/4, p3, p3/4	aOsc1     poscil    iAmp, iFrq, giSine	outs      aOsc1*kenv*kPan, aOsc1*kenv*(1-kPan)endin
</CsInstruments><CsScore>i 1 0 20</CsScore></CsoundSynthesizer>